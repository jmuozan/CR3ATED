<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>MediaPipe Hands Drawing</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@0.9.2/css/bulma.min.css">
  <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils@0.1/control_utils.css" crossorigin="anonymous">
  <link rel="stylesheet" type="text/css" href="demo.css" crossorigin="anonymous">
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.1/camera_utils.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils@0.1/control_utils.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils@0.2/drawing_utils.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.1/hands.js" crossorigin="anonymous"></script>
  <style>
    .input_video3 {
      display: none;
    }

    .output3, .draw-canvas {
      max-width: 640px;
      height: 480px;
      display: block;
      border: 2px solid black; /* A border around the camera and drawing canvases */
    }

    .full-screen-container {
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      width: 100vw;
      height: 100vh;
    }

    .canvas-container {
      display: flex;
      justify-content: space-around;
      width: 100%;
    }

    .clear-button-container {
      margin-top: 20px;
    }

    .button-container {
      margin-top: 10px;
    }
  </style>
</head>
<body>
  <!-- BULMA NAVBAR -->
  <nav class="navbar" role="navigation" aria-label="main navigation">
    <div class="navbar-brand">
      <a role="button" class="navbar-burger" aria-label="menu" aria-expanded="false" data-target="navbarBasicExample">
        <span aria-hidden="true"></span>
        <span aria-hidden="true"></span>
        <span aria-hidden="true"></span>
      </a>
    </div>
    <div id="navbarBasicExample" class="navbar-menu">
      <div class="navbar-start">
        <a class="navbar-item" href="face.html">Face</a>
      </div>
    </div>
  </nav>

  <div class="full-screen-container">
    <div class="canvas-container">
      <!-- Display camera feed -->
      <canvas class="output3" width="640px" height="480px"></canvas>

      <!-- Drawing canvas on the right -->
      <canvas class="draw-canvas" width="640px" height="480px"></canvas>
    </div>

    <!-- Clear Canvas and Download Image Buttons -->
    <div class="button-container">
      <button class="button is-danger" onclick="clearDrawingCanvas()">Clear Canvas</button>
      <button class="button is-primary" onclick="downloadCanvasAsImage()">Download PNG</button>
    </div>
  </div>
  
  <video class="input_video3"></video>

  <script type="text/javascript">
    const video3 = document.getElementsByClassName('input_video3')[0];
    const out3 = document.getElementsByClassName('output3')[0];
    const canvasCtx3 = out3.getContext('2d');

    const drawCanvas = document.getElementsByClassName('draw-canvas')[0];
    const drawCtx = drawCanvas.getContext('2d');

    let prevX = null, prevY = null;
    let isDrawing = false;  // Initially set to false, only draws on demand

    const movementThreshold = 10;  // Minimum distance to generate a line segment (measured in pixels)
    const smoothingFactor = 0.2;   // For smoothing hand movements
    const fingerCloseThreshold = 0.05;  // Threshold for finger proximity to trigger toggle

    // Utility function to compute the Euclidean distance between two 3D points
    function calculateDistance3D(x1, y1, z1, x2, y2, z2) {
      return Math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2 + (z1 - z2) ** 2);
    }

    // Helper function to apply movement smoothing
    function smoothPosition(prevValue, newValue, factor) {
      return prevValue * (1 - factor) + newValue * factor;
    }

    function onResultsHands(results) {
      // Clear the camera output pane
      canvasCtx3.save();
      canvasCtx3.clearRect(0, 0, out3.width, out3.height);
      canvasCtx3.drawImage(results.image, 0, 0, out3.width, out3.height);

      // Check if any hand landmarks are detected
      if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
        // Focus on the first hand
        const landmarks = results.multiHandLandmarks[0];

        // Get the index finger tip (landmark 8) and middle finger tip (landmark 12)
        const fingerTip = landmarks[8];
        const middleTip = landmarks[12];

        // Convert normalized coordinates to canvas dimensions for the index finger
        const x = fingerTip.x * drawCanvas.width;
        const y = fingerTip.y * drawCanvas.height;

        // Process proximity between the index finger tip (landmark 8) and middle finger tip (landmark 12)
        const handDistance = calculateDistance3D(
          fingerTip.x, fingerTip.y, fingerTip.z,
          middleTip.x, middleTip.y, middleTip.z
        );

        // If the distance between finger 8 and 12 is below the threshold, toggle drawing mode
        if (handDistance < fingerCloseThreshold) {
          isDrawing = false;
        } else {
          isDrawing = true;
        }

        // If in drawing mode, process and draw on the canvas
        if (isDrawing) {
          if (prevX != null && prevY != null) {
            const smoothX = smoothPosition(prevX, x, smoothingFactor);
            const smoothY = smoothPosition(prevY, y, smoothingFactor);

            // Draw only if finger movement exceeds a threshold
            if (calculateDistance3D(prevX, prevY, 0, x, y, 0) > movementThreshold) {
              drawCtx.beginPath();
              drawCtx.moveTo(prevX, prevY);
              drawCtx.lineTo(smoothX, smoothY);
              drawCtx.strokeStyle = "black";  // Black color for drawing
              drawCtx.lineWidth = 3;          // Line thickness
              drawCtx.stroke();
            }

            // Update previous position with new smoothed position
            prevX = smoothX;
            prevY = smoothY;
          } else {
            // Initialize position for the first frame
            prevX = x;
            prevY = y;
          }
        } else {
          // If not drawing, reset previous coordinates
          prevX = null;
          prevY = null;
        }
      } else {
        // Reset previous coordinates if no hand is detected
        prevX = null;
        prevY = null;
      }

      // Restore the camera output context
      canvasCtx3.restore();

      // Draw a border around the drawing area
      drawCtx.strokeStyle = "black";
      drawCtx.lineWidth = 2;
      drawCtx.strokeRect(0, 0, drawCanvas.width, drawCanvas.height);
    }

    // Initialize MediaPipe Hands solution and set options
    const hands = new Hands({ locateFile: (file) => {
        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.1/${file}`;
      }
    });

    hands.setOptions({
      selfieMode: true,
      maxNumHands: 2,  // Allow up to two hands, but we follow only one
      minDetectionConfidence: 0.5,
      minTrackingConfidence: 0.5
    });

    hands.onResults(onResultsHands);

    // Start camera input
    if (video3) {
      const camera = new Camera(video3, {
        onFrame: async () => {
          await hands.send({image: video3});
        },
        width: 640,
        height: 480
      });
      camera.start();
    } else {
      console.error("Camera not found");
    }

    // Function to clear the current drawing on the canvas
    function clearDrawingCanvas() {
      drawCtx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);
    }

    // Function to download the canvas content as a PNG file
    function downloadCanvasAsImage() {
      const image = drawCanvas.toDataURL("image/png");
      const link = document.createElement('a');
      link.href = image;
      link.download = 'drawing.png'; // Name of the downloaded image
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    }

  </script>
</body>
</html>